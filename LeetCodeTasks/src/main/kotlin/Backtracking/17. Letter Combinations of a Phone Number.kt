package edu.learn.Backtracking

/**
 * Класс Solution содержит реализацию алгоритма для генерации всех возможных комбинаций букв,
 * соответствующих заданной строке цифр, основываясь на стандартном сопоставлении цифр с буквами на клавиатуре телефона.
 *
 * Например, для входной строки "23" алгоритм генерирует комбинации: "ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf".
 */

/**
 # Сложность
 * - Временная сложность: O(n * 4^n)
 *   - В худшем случае (например, если каждая цифра соответствует 4 буквам, как для '7' или '9'),
 *     алгоритм генерирует 4^n комбинаций, при этом на построение каждой комбинации требуется
 *     O(n) операций (из-за обхода глубины рекурсии равной n).
 *
 * - Пространственная сложность: O(n * 4^n)
 *   - Это включает в себя пространство, необходимое для хранения всех комбинаций (выходное пространство).
 *   - Дополнительное пространство, используемое для рекурсивного вызова (глубина рекурсии и StringBuilder),
 *     составляет O(n), что в данном случае не является доминирующим.
 */

class Solution {

    /**
     * Массив строк, где индекс соответствует цифре телефона,
     * а строка в элементе содержит буквы, ассоциированные с этой цифрой.
     *
     * Пример: map[2] = "abc", map[3] = "def" и т.д.
     * Элементы для цифр 0 и 1 оставлены пустыми, так как они обычно не ассоциируются с буквами.
     */
    val map: Array<String> = arrayOf("", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")

    /**
     * Список, в котором сохраняются все сгенерированные комбинации букв.
     */
    val resultList = mutableListOf<String>()

    /**
     * Генерирует все возможные комбинации букв, соответствующие заданной строке цифр.
     *
     * @param digits Строка, состоящая из цифр от 2 до 9, для которых необходимо найти комбинации букв.
     * @return Список строк, каждая из которых является комбинацией букв, полученной на основе сопоставления цифр.
     *         Если входная строка пустая, возвращается пустой список.
     */
    fun letterCombinations(digits: String): List<String> {
        // Если входная строка пустая, возвращаем пустой список комбинаций
        if (digits.isEmpty())
            return resultList

        // Создаем экземпляр StringBuilder для построения комбинаций без лишней аллокации новых строк
        val builder = StringBuilder()
        // Запускаем рекурсивное построение комбинаций, начиная с первого символа (индекс 0) и пустой строки результата
        solution(digits, builder, 0)
        return resultList
    }

    /**
     * Рекурсивно строит комбинации букв, используя StringBuilder для накопления текущей комбинации.
     *
     * @param digits Исходная строка цифр.
     * @param builder StringBuilder, в который добавляются буквы для формирования комбинации.
     * @param index  Текущий индекс в строке digits, указывающий на цифру, для которой необходимо добавить соответствующие буквы.
     *
     * Алгоритм:
     * - Если индекс достиг длины строки digits, то текущая комбинация в builder считается полной и добавляется
     *   в результат.
     * - Иначе, для каждой буквы, соответствующей цифре digits[index] (из массива map), добавляем букву в builder,
     *   вызываем рекурсивно функцию для следующего индекса, а затем удаляем последнюю букву для возврата к предыдущему состоянию.
     */
    fun solution(digits: String, builder: StringBuilder, index: Int) {
        if (index == digits.length) {
            resultList.add(builder.toString())
        } else {
            // Получаем строку с буквами, соответствующими текущей цифре
            val letters = map[digits[index] - '0']
            for (letter in letters) {
                // Добавляем букву к текущей комбинации
                builder.append(letter)
                // Рекурсивно обрабатываем следующий индекс
                solution(digits, builder, index + 1)
                // Удаляем последнюю букву, чтобы вернуть builder в исходное состояние для следующей итерации
                builder.deleteCharAt(builder.length - 1)
            }
        }
    }
}

fun main() {
    val solution = Solution()
    println(solution.letterCombinations("23"))
}